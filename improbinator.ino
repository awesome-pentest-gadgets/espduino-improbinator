/*
    NO LICENSES

    DISCLAIMER: By downloading and executing this sketch you might commit a criminal fellony in some country.

    This code is for EDUCATIONAL USE ONLY.

    No warranties, no support, no batteries included.

    Author: Christopher Isene <christopher.isene@gmail.com> @cisene
    Revision: 201610291339

    Target device: ESPduino

    Inspiration:
      https://hackaday.com/tag/wifi-throwie/

*/
#include <ESP8266WiFi.h>

extern "C" {
#include "user_interface.h"
}

#define BUILTIN_LED 16
#define USE_SERIAL Serial

/* ======================================================================== */
uint8_t phones[] = {
  0x00, 0x1E, 0x52, // Apple
  0x00, 0x1F, 0xF3, // Apple
  0x00, 0x24, 0x36, // Apple
  0x00, 0x26, 0xBB, // Apple
  0x00, 0x37, 0x6D, // Samsung
  0x02, 0x15, 0x99, // Samsung
  0x02, 0x1A, 0x11, // HTC
  0x04, 0xF7, 0xE4, // Apple
  0x08, 0x63, 0x61, // Huawei
  0x0C, 0x96, 0xBF, // Huawei
  0x10, 0x9A, 0xDD, // Apple
  0x10, 0xC6, 0x1F, // Huawei
  0x18, 0x87, 0x96, // HTC
  0x1C, 0xB0, 0x94, // HTC
  0x20, 0x02, 0xAF, // Samsung
  0x20, 0x64, 0x32, // Samsung
  0x20, 0xC9, 0xD0, // Apple
  0x24, 0xDB, 0xAC, // Huawei
  0x28, 0x37, 0x37, // Apple
  0x28, 0x3C, 0xE4, // Huawei
  0x28, 0xCF, 0xDA, // Apple
  0x2C, 0x26, 0xC5, // ZTE
  0x30, 0xF7, 0xC5, // Apple
  0x32, 0xCD, 0xA7, // Samsung
  0x34, 0x6B, 0xD3, // Huawei
  0x34, 0xCD, 0xBE, // Huawei
  0x34, 0xE0, 0xCF, // ZTE
  0x38, 0xAA, 0x3C, // Samsung
  0x3C, 0x47, 0x11, // Huawei
  0x40, 0x4D, 0x8E, // Huawei
  0x40, 0xB3, 0x95, // Apple
  0x40, 0xCB, 0xA8, // Huawei
  0x40, 0xF3, 0x08, // Samsung
  0x48, 0x28, 0x2F, // ZTE
  0x4C, 0x54, 0x99, // Huawei
  0x4C, 0x8B, 0xEF, // Huawei
  0x50, 0x9F, 0x27, // Huawei
  0x50, 0xCC, 0xF8, // Samsung
  0x54, 0x72, 0x4F, // Apple
  0x54, 0xE4, 0x3A, // Apple
  0x58, 0x1F, 0xAA, // Apple
  0x5C, 0x0A, 0x5B, // Samsung
  0x5C, 0x0E, 0x8B, // Motorola
  0x5C, 0x7D, 0x5E, // Huawei
  0x5C, 0x96, 0x9D, // Apple
  0x5C, 0xF8, 0xA1, // Samsung
  0x60, 0x33, 0x4B, // Apple
  0x68, 0xA8, 0x6D, // Apple
  0x6C, 0x70, 0x9F, // Apple
  0x6C, 0x8B, 0x2F, // ZTE
  0x70, 0x56, 0x81, // Apple
  0x70, 0x73, 0xCB, // Apple
  0x78, 0xD6, 0xF0, // Samsung
  0x7C, 0x61, 0x93, // HTC
  0x7C, 0xD1, 0xC3, // Apple
  0x80, 0xEA, 0x96, // Apple
  0x84, 0x38, 0x38, // Samsung
  0x84, 0x74, 0x2A, // ZTE
  0x88, 0x1F, 0xA1, // Apple
  0x88, 0x30, 0x8A, // Samsung
  0x88, 0x32, 0x9B, // Samsung
  0x88, 0x53, 0xD4, // Huawei
  0x90, 0x18, 0x7C, // Samsung
  0x90, 0x21, 0x55, // HTC
  0x90, 0x72, 0x40, // Apple
  0x90, 0x84, 0x0D, // Apple
  0x90, 0xB9, 0x31, // Apple
  0x98, 0x0C, 0x82, // Samsung
  0x9C, 0xA9, 0xE4, // ZTE
  0xA0, 0x0B, 0xBA, // Samsung
  0xA4, 0xC3, 0x61, // Apple
  0xA8, 0xA6, 0x68, // ZTE
  0xAC, 0xCF, 0x5C, // Apple
  0xAC, 0xE2, 0x15, // Huawei
  0xAC, 0xE8, 0x7B, // Huawei
  0xB0, 0x5B, 0x67, // Huawei
  0xB4, 0xC7, 0x99, // Motorola
  0xB8, 0x8D, 0x12, // Apple
  0xB8, 0xC7, 0x5D, // Apple
  0xB8, 0xE8, 0x56, // Apple
  0xBC, 0x25, 0xE0, // Huawei
  0xC8, 0x51, 0x95, // Huawei
  0xC8, 0xD1, 0x5E, // Huawei
  0xCC, 0x3A, 0x61, // Samsung
  0xCC, 0x7B, 0x35, // ZTE
  0xD0, 0x22, 0xBE, // Samsung
  0xD0, 0x2D, 0xB3, // Huawei
  0xD4, 0x20, 0x6D, // HTC
  0xD4, 0x6E, 0x5C, // Huawei
  0xD8, 0x9E, 0x3F, // Apple
  0xE0, 0xF8, 0x47, // Apple
  0xE4, 0xCE, 0x8F, // Apple
  0xE8, 0x08, 0x8B, // Huawei
  0xE8, 0x50, 0x8B, // Samsung
  0xE8, 0x99, 0xC4, // HTC
  0xF0, 0x25, 0xB7, // Samsung
  0xF0, 0xD1, 0xA9, // Apple
  0xF0, 0xF6, 0x1C, // Apple
  0xF8, 0x3D, 0xFF, // Huawei
  0xF8, 0xDB, 0x7F  // HTC
};
/* ======================================================================== */
uint8_t accesspoints[] = {
  0x00, 0x01, 0x38, // XAVi Technologies Corp.
  0x00, 0x03, 0x52, // Colubris Networks
  0x00, 0x11, 0x95, // D-Link
  0x00, 0x13, 0x46, // D-Link
  0x00, 0x16, 0xA6, // Dovado
  0x00, 0x18, 0x4D, // Netgear
  0x00, 0x19, 0x5B, // D-Link
  0x00, 0x19, 0xCB, // Zyxel
  0x00, 0x1A, 0x1E, // Aruba Networks
  0x00, 0x1B, 0x2F, // Netgear
  0x00, 0x1C, 0xF0, // D-Link
  0x00, 0x1D, 0xA1, // Cisco
  0x00, 0x1E, 0x2A, // Netgear
  0x00, 0x1F, 0x33, // Netgear
  0x00, 0x1F, 0x9F, // Thomson
  0x00, 0x22, 0x07, // Inteno
  0x00, 0x22, 0x3F, // Netgear
  0x00, 0x22, 0x56, // Cisco
  0x00, 0x24, 0x01, // D-Link
  0x00, 0x24, 0x6C, // Aruba Networks
  0x00, 0x24, 0x8C, // ASUSTek Computer Inc.
  0x00, 0x25, 0x45, // Cisco
  0x00, 0x26, 0x44, // Thomson
  0x00, 0x26, 0x5A, // D-Link
  0x00, 0x3A, 0x98, // Cisco
  0x00, 0x3A, 0x99, // Cisco
  0x00, 0x8E, 0xF2, // Netgear
  0x04, 0xA1, 0x51, // Netgear
  0x06, 0x27, 0x22, // Ubiquiti Networks
  0x08, 0x60, 0x6E, // ASUSTek Computer Inc.
  0x08, 0x76, 0xFF, // Thomson
  0x0A, 0x18, 0xD6, // Ubiquiti Networks
  0x0C, 0x85, 0x25, // Cisco
  0x0C, 0xD9, 0x96, // Cisco
  0x10, 0x0D, 0x7F, // Netgear
  0x1C, 0x6A, 0x7A, // Cisco
  0x1C, 0xAA, 0x07, // Cisco
  0x1C, 0xE6, 0xC7, // Cisco
  0x20, 0x0C, 0xC8, // Netgear
  0x20, 0x4E, 0x7F, // Netgear
  0x20, 0xE5, 0x2A, // Netgear
  0x24, 0x01, 0xC7, // Cisco
  0x24, 0xDE, 0xC6, // Aruba Networks
  0x28, 0xC6, 0x8E, // Netgear
  0x2C, 0x5D, 0x93, // Ruckus Wireless
  0x2C, 0xB0, 0x5D, // Netgear
  0x2C, 0xE6, 0xCC, // Ruckus Wireless
  0x30, 0x46, 0x9A, // Netgear
  0x30, 0x91, 0x8F, // Technicolor USA Inc.
  0x34, 0xA8, 0x4E, // Cisco
  0x40, 0x4A, 0x03, // Zyxel
  0x44, 0x94, 0xFC, // Netgear
  0x4C, 0x60, 0xDE, // Netgear
  0x54, 0x67, 0x51, // Compal Broadband Networks, Inc.
  0x58, 0x98, 0x35, // Technicolor USA Inc.
  0x58, 0xF3, 0x9C, // Cisco
  0x5C, 0x35, 0x3B, // Compal Broadband Networks, Inc.
  0x5C, 0x50, 0x15, // Cisco
  0x64, 0xA0, 0xE7, // Cisco
  0x6C, 0xB0, 0xCE, // Netgear
  0x6C, 0xF3, 0x7F, // Aruba Networks
  0x70, 0x10, 0x5C, // Cisco
  0x70, 0x71, 0xBC, // Pegatron
  0x74, 0x44, 0x01, // Netgear
  0x78, 0xBA, 0xF9, // Cisco
  0x80, 0x37, 0x73, // Netgear
  0x84, 0x1B, 0x5E, // Netgear
  0x84, 0x78, 0xAC, // Cisco
  0x9C, 0x97, 0x26, // Technicolor USA Inc.
  0x9C, 0xD3, 0x6D, // Netgear
  0xA0, 0x21, 0xB7, // Netgear
  0xA0, 0x63, 0x91, // Netgear
  0xA4, 0x0C, 0xC3, // Cisco
  0xA4, 0x18, 0x75, // Cisco
  0xA4, 0x2B, 0x8C, // Netgear
  0xA4, 0x56, 0x30, // Cisco
  0xA4, 0xB1, 0xE9, // Technicolor USA Inc.
  0xB0, 0xB2, 0xDC, // Zyxel
  0xB8, 0x62, 0x1F, // Cisco
  0xBC, 0xEE, 0x7B, // ASUSTek Computer Inc.
  0xC0, 0x25, 0x5C, // Cisco
  0xC0, 0x3F, 0x0E, // Netgear
  0xC0, 0x7B, 0xBC, // Cisco
  0xC4, 0x01, 0x7C, // Ruckus Wireless
  0xC4, 0x04, 0x15, // Netgear
  0xC4, 0x3D, 0xC7, // Netgear
  0xC4, 0xEA, 0x1D, // Technicolor USA Inc.
  0xC6, 0xEA, 0x1D, // Technicolor USA Inc.
  0xC8, 0x6C, 0x87, // Zyxel
  0xC8, 0xBE, 0x19, // D-Link
  0xC8, 0xD3, 0xA3, // D-Link
  0xD0, 0x57, 0x4C, // Cisco
  0xD8, 0x50, 0xE6, // ASUSTek Computer Inc.
  0xD8, 0xC7, 0xC8, // Aruba Networks
  0xDC, 0x53, 0x7C, // Compal Broadband Networks, Inc.
  0xE0, 0x3F, 0x49, // ASUSTek Computer Inc.
  0xE0, 0x69, 0x95, // Pegatron
  0xE0, 0x91, 0xF5, // Netgear
  0xF4, 0x4E, 0x05, // Cisco
  0xF4, 0xCF, 0xE2, // Cisco
};
/* ======================================================================== */
char* ssids[] = {
  "ASUS",
  "All Station Guests",
  "BUTIKEXTVIDEO",
  "DOVADO",
  "GIGABYTE",
  "Glocalnet Wireless",
  "Guest",
  "Guestnet",
  "H&M Free WiFi",
  "ICA - Gratis Wifi",
  "IKEA WiFi",
  "Linksys",
  "Mobile",
  "NETGEAR",
  "Net99",
  "Pressbyran",
  "QuickNetFree",
  "Radisson_Guest",
  "RoverRabbit",
  "SEB Corporate",
  "SEB Guest",
  "SEB Internet",
  "SJ",
  "SJ-Guest",
  "Swedbank Guest",
  "TP-LINK",
  "Telia wifi",
  "Telia wifi1x",
  "Telia-testsignal-bg",
  "VOICE",
  "Vasteras Stad Guest Net",
  "WLAN Zone - The Cloud",
  "WirelessICC",
  "WirelessMobile",
  "arosnet",
  "belkin54g",
  "d-link",
  "default",
  "dlink",
  "edu_internet",
  "eduroam",
  "espressohouse",
  "guest_net",
  "homerun",
  "homerun1x",
  "mobile net",
  "mycloud",
  "scandic_easy",
  "service",
  "skynet",
  "wireless",
  "zyxel"
};
/* ======================================================================== */
// Probe Request packet buffer
uint8_t probereq[128] = {
  /* 00 */  0x40,                               /* Management Frame - Probe Request */
  /* 01 */  0x00,                               /* Frame Control Field #2 - always ZERO */
  /* 02 */  0x00, 0x00,                         /* Duration - always ZERO */
  /* 04 */  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* Destination address */
  /* 0a */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* Source address */
  /* 10 */  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* Broadcast */
  /* 16 */  0x90, 0x00,                         /* Sequence control - no fragment */
  /* 18 */  0x00, 0x0f,
  /* 1a */  0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
  /* 28 */  0x01, 0x04,
  /* 2a */  0x82,                               /* Basic rate - 1.0Mbit/s */
  /* 2c */  0x84,                               /* Basic rate - 2.0Mbit/s */
  /* 2d */  0x8b,                               /* Basic rate - 5.5Mbit/s */
  /* 2e */  0x96                                /* Basic rate - 11Mbit/s  */
};

/* ======================================================================== */
uint8_t clientBuffer[] = {

  /*
     0x00 - 0x2e is Probe Request frame payload
     0x2f - Spare byte
  */

  /* 00 */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  /* 01 */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  /* 02 */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  /* 03 */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  /* 04 */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  /* 05 */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  /* 06 */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  /* 07 */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00


};
/* ======================================================================== */
uint8_t clientBufferIndex[] = {
  /*
     As many elements as buffer slots

     0x00 - Empty/free slot
     non-zero - Occupied slot

  */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* ======================================================================== */
uint8_t packet[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
/* ======================================================================== */
int flipflop = 0;

void setup() {
  USE_SERIAL.begin(115200);
  for (uint8_t t = 5; t > 0; t--) {
    USE_SERIAL.printf("[SETUP] WAIT %d...\n", t);
    USE_SERIAL.flush();
    delay(1000);
  }

  /* Define BUILTIN_LED */
  pinMode(BUILTIN_LED, OUTPUT);

  /* Set Wifi operation mode */
  wifi_set_opmode(STATION_MODE);
  wifi_promiscuous_enable(1);

  Serial.println("Ready!");
}
/* ======================================================================== */
void loop() {
  unsigned int i;
  unsigned int slotIndex;
  unsigned int prf;
  unsigned int oui_idx;
  unsigned int p;
  unsigned int channel;

  /* TODO:
  
    clientBufferIndex[0]
      always stuck on ZERO causing Prepare portion of the code to be
      run on each iteration, packet will not be sent as trigger is TTL != 0

    Destination MAC
      Decide between broadcast FF:FF:FF:FF:FF:FF or a faked OUI + random 3 bytes

    SSID
      Currently 'AAAAAAAAAAAAAAA' but should be triggered on Destination MAC,
      where otherwise a fake SSID string should be copied into the frame.
      Might need adjustment and adaption to SSID length.

    Capability bytes
      Check captured packets and imitate/mimic the capabilities as we want
      to look __exactly__ like random smartphones.
  */


  /* TTL timing for buffer entries */
  for (i = 0; i <= (sizeof(clientBufferIndex) - 0x01); i = i + 0x01) {
    Serial.printf("Slot %d has TTL %d seconds\n", i, clientBufferIndex[i]);
    if (clientBufferIndex[i] != 0x00) {
      clientBufferIndex[i] = (clientBufferIndex[i] - 0x01);
    }
  }

  /* Prepare new faked client into buffer */
  for (i = 0x00; i <= (sizeof(clientBufferIndex) - 0x01); i = i + 0x01) {
    if (clientBufferIndex[i] == 0x00) {
      Serial.printf("START Prepare slot %d\n", i);

      /* Set a random TTL */
      clientBufferIndex[i] = random(0x0f, 0x5a);
      Serial.printf("\tTTL for slot %d set to %d\n", i, clientBufferIndex[i]);

      slotIndex = (i * 0x30);
      Serial.printf("\tSlot %d has offset 0x%4X\n", i, slotIndex);

      /* Copy template into buffer */
      for (prf = 0; prf <= 0x2f; prf = prf + 0x01) {
        clientBuffer[slotIndex + prf] = probereq[prf];
      }

      /* Set randomized OUI + 3 random bytes as source address */
      oui_idx = (random(0, sizeof(phones)) * 0x03);
      for (p = 0x00; p <= 0x03; p = p + 1) {
        clientBuffer[(slotIndex + 0x0a) + p] = phones[oui_idx + p];
      }
      for (p = 0x00; p <= 0x03; p = p + 1) {
        clientBuffer[(slotIndex + 0x0d) + p] = random(0x00, 0xff);
      }

      char tmpBuf[17];
      sprintf(
        tmpBuf,
        "%02X:%02X:%02X:%02X:%02X:%02X",
        clientBuffer[(slotIndex + 0x0a) + 0],
        clientBuffer[(slotIndex + 0x0a) + 1],
        clientBuffer[(slotIndex + 0x0a) + 2],
        clientBuffer[(slotIndex + 0x0a) + 3],
        clientBuffer[(slotIndex + 0x0a) + 4],
        clientBuffer[(slotIndex + 0x0a) + 5]
      );

      Serial.printf("\tSource MAC: %s\n", tmpBuf);


      /* Copy randomized SSID to buffer */

      /* Adjust buffer for SSID length */

      /* Fiddle with speed capabilities */

      Serial.printf("END Prepare slot %d\n", i);
    }
  }

  /* Send frames */
  for (i = 0; i <= (sizeof(clientBufferIndex) - 0x01); i = i + 0x01) {
    if (clientBufferIndex[i] != 0x00) {
      slotIndex = (i * 0x30);

      /* Copy buffer slot to packet */
      for (prf = 0; prf <= 0x2f; prf = prf + 0x01) {
        packet[prf] = clientBuffer[(slotIndex) + prf];
      }

      /* Randomize channel */
      channel = random(0x01, 0x0e);
      wifi_set_channel(channel);

      /* Broadcast broadcast broadcast! */
      for (p = 0; p <= 0x02; p = p + 1) {
        wifi_send_pkt_freedom(packet, 0x2f, 0);
      }
    }

  }

  Serial.println("====================================================================");

  /* Flipflop the blue LED to indicate activity */
  if (flipflop == 0x00) {
    digitalWrite(BUILTIN_LED, LOW);
    flipflop = 0x01;
  } else {
    digitalWrite(BUILTIN_LED, HIGH);
    flipflop = 0x00;
  }

  delay(0x3e8);
}
